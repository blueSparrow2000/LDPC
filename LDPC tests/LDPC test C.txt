- C code 
n = 4000, k = 3600
BER = 10^(-4) : same with all cases


Codeword generated
ECO performed => maybe too much error
Matches: 0 / 400
Success? NO
Elapsed time: 314.720 seconds


n = 4000, k = 3700
Codeword generated
ECO performed
Not enough dual vectors!
Found: 299
Matches: 225 / 300
Success? NO
Elapsed time: 242.773000 seconds



n = 3600, k = 3000
Codeword generated
ECO performed
Not enough dual vectors!
Found: 599 -> 왜 이런식으로 599개 같이 1개 모자란 숫자로 찾아지는지 모르겠음. 잘못 코딩했나? 아니면 마지막 하나를 놓지는 건가?
Matches: 444 / 600
Success? NO
Elapsed time: 632.438000 seconds


n = 3000, k = 2700
Codeword generated
ECO performed
Not enough dual vectors!
Found: 299
Matches: 225 / 300
Success? NO
Elapsed time: 99.676000 seconds



n = 2000, k = 1800
Codeword generated
ECO performed
Not enough dual vectors!
Found: 199
Matches: 148 / 200
Success? NO
Elapsed time: 28.136000 seconds



n = 1000, k = 900
Error bits = 578 (pooling factor = 5)
Codeword generated
ECO performed
Not enough dual vectors!
Found: 99
Matches: 75 / 100
Success? NO
Elapsed time: 5.370000 seconds





# C 코드 이상함 
dual vector 가 하나씩 모자라고... 뭔가 이상.
ECO나 sparse col exraction이 이상함

python 코드는 2개 4개 등등 부족한 개수가 다양한데, 이상하게 C 코드는 부족한게 딱 1개씩 생김... 

==> OPENMP parallel processing 때문에 이상하게 될수도 있어서 해제해 봤다. 
근데 아마 아닐듯. 에러가 아주 적은 상황 (2개 등) 에선 잘 동작했기에 OPENMP 문제는 아닐 것이다.
지금은 에러가 500비트가 넘는 상황이다. 
코드워드 길이 1000, 코드워드 개수는 5000개 일때


pooling factor 문제도 아님 => pool factor 가 2이어도 안됨!
















