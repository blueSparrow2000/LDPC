import numpy as np
from LDPC_sampler import *
from variables import *
import time
from verifier import compare_matrix

'''
This code was generated by ChatGPT

1. Iteratively tries to fix errors using Gallager-B majority logic.

2. Rolls back if syndrome not fixed, or final word is “heavier” than input.

3. Has safeguards: tie-breaking, stagnation escape, rollback rules.

'''

def ldpc_bitflip_majority_decode(H, codewords, max_iter=100, rng=None):
    """
    Majority-logic (Gallager-B style) hard-decision LDPC decoder.

    Inputs
    ------
    H : (m x n) int64/0-1 numpy array  -- parity-check matrix (m = n - k)
    codewords : (B x n) int64/0-1 numpy array  -- each row a received word (possibly with errors)
    max_iter : int  -- maximum iterations
    rng : int or np.random.Generator or None -- for random tie-break

    Returns
    -------
    decoded : (B x n) int64 array   -- corrected words
    success : (B,) bool array       -- True if zero syndrome achieved
    iters   : (B,) int array        -- iterations used
    syndromes : (B x m) int64 array -- final syndromes
    flips   : (B,) int array        -- total number of bit flips performed
    """
    # --- sanitize inputs ---
    weight_tolerance = 2 # code word length가 100 단위라면 2정도 tolerance로 잘 해결됨

    H = (np.array(H)).astype(np.uint8)
    C = (np.array(codewords)).astype(np.uint8)
    B, n = C.shape
    m, nH = H.shape
    if n != nH:
        raise ValueError(f"Length mismatch: codeword n={n} vs H.n={nH}")
    rng = np.random.default_rng(rng)

    # Precompute degrees and neighbors
    H_int = H.astype(np.uint8)
    deg_v = H_int.sum(axis=0)              # degree per variable - H mat의 column weight (한 col의 weight) = 해당 bit가 몇개의 parity check equation에 포함되어 있는지
    tau = (deg_v // 2).astype(np.uint8)    # majority thresholds - col wieight의 절반을 사용 (jth bit은 이 값보다 더 적은 parity equation을 만족시킬때 bit flip을 하도록 한다) = 해당 bit는 해당 bit가 포함된 parity check eqn의 절반보다 더 많은 오류가 검출되었을 시 bitflip을 수행한다

    decoded   = C.copy()
    success   = np.zeros(B, dtype=bool)
    iters     = np.zeros(B, dtype=int)
    syndromes = np.zeros((B, m), dtype=np.uint8)
    flips     = np.zeros(B, dtype=int)

    # Process each codeword independently - numba parallel 가능. 그러나 지원이 안되는 함수들은 고쳐줘야 함 (루프로 풀어 써줘야 함)
    for b in range(B):
        w = decoded[b].copy()
        orig_w = C[b].copy()
        last_w   = None
        total_flips = 0

        for it in range(1, max_iter + 1):
            # Syndrome s = H * w (mod 2)
            s = (H_int @ w) & 1
            if not np.any(s): # all parity check eqn are already satisfied
                success[b] = True
                iters[b] = it - 1
                syndromes[b] = s.astype(np.uint8)

                # --- rollback check: hamming weight ---
                if w.sum() > orig_w.sum()+weight_tolerance:
                    decoded[b] = orig_w.copy()   # <<< rollback >>>
                    success[b] = False           # treat as fail
                else:
                    decoded[b] = w

                flips[b] = total_flips
                break

            # Unsatisfied checks per variable
            u = (H_int.T @ s).astype(np.uint8)
            flip_mask = (u > tau) & (deg_v > 0)


            # If no variable passes majority threshold, pick the variable with maximum unsatisfied checks and flip it (tie broken randomly).
            if not np.any(flip_mask):
                umax = int(u.max())
                if umax > 0:
                    cand = np.flatnonzero((u == umax) & (deg_v > 0))
                    j = int(rng.choice(cand))
                    w[j] ^= 1
                    total_flips += 1
                else:
                    # if u.max() == 0, (no information), decoding is stuck → rollback to original
                    # Stuck: decoding failed
                    success[b] = False
                    iters[b] = it
                    syndromes[b] = s.astype(np.uint8)
                    decoded[b] = orig_w.copy()   # <<< rollback >>>
                    flips[b] = total_flips
                    break
            # Flip all variables that exceeded majority threshold
            else: # 모든 bit를 한번에 flip함 => 이게 맞나? 하나씩 순차적으로 해봐야 하는거 아니야? 하나하고 해보고 이런 식으로... 한번에 다 하는게 맞나
                w[flip_mask] ^= 1
                total_flips += int(flip_mask.sum())

            # If w did not change compared to last iteration → decoder is stuck in a loop
            # Break stagnation by forcing one flip (again choose max u)
            if last_w is not None and np.array_equal(w, last_w):
                umax = int(u.max())
                if umax > 0:
                    cand = np.flatnonzero((u == umax) & (deg_v > 0))
                    j = int(rng.choice(cand))
                    w[j] ^= 1
                    total_flips += 1

            last_w = w.copy()

            # After reaching max iteration (stop condition)
            if it == max_iter:
                s = (H_int @ w) & 1
                success[b] = (np.count_nonzero(s) == 0)
                iters[b] = it
                syndromes[b] = s.astype(np.uint8)

                # If success but decoded word is heavier than original → rollback
                if success[b] and (w.sum() <= orig_w.sum() + weight_tolerance): # roll back when weight increased than the original codeword
                    decoded[b] = w
                else: # Otherwise accept w
                    decoded[b] = orig_w.copy()   # <<< rollback >>>
                    success[b] = False
                flips[b] = total_flips

    return decoded, success, iters, syndromes, flips

# ------------------------ #
# Quick self-test example: #
# ------------------------ #
if __name__ == "__main__1":

    H, A = sample_LDPC(codeword_len, databit_num, density=density, pooling_factor=pooling_factor,
                       noise_level=noise_level, save_noise_free=True)
    A_error_free = read_matrix('error_free_codeword')

    # 원래 codeword matrix 중에 correct codeword의 개수 (error 개수는 10^(-4)으로 고정되어있지만, 그게 한 코드워드에 여러군데 발생했을 수 있음)
    # 이 값을 봐야 몇개를 더 디코딩하는데 성공했는지 알 수 있음
    total_codewords = pooling_factor * codeword_len
    correct_codewords = compare_matrix(A_error_free, A)
    # noisy_codewords = total_codewords - correct_codewords
    print("Codeword generated: noise is added, so correct  prior codeword number is as follows")
    print("Correct / Total = {} / {}".format(correct_codewords,total_codewords) )


    # H = H[:parity_num // 2]  # only use half of H
    H = H[:3*parity_num//4] # only use quarter

    start_time = time.time()
    decoded, ok, its, syn, flips = ldpc_bitflip_majority_decode(H, A, max_iter=50, rng=0)
    print("Total elapsed time: %s seconds" % round(time.time() - start_time, 3))
    # print("Decoded array")
    # print_arr(decoded)
    # print("Success:", ok, "Iters:", its, "Flips:", flips)

    # print("Original array")
    # print_arr(A_error_free)

    # print("Noisy array")
    # print_arr(A)

    print()
    # compare matrix
    if (A_error_free == decoded).all():
        print("Correctly recovered!")
    else:
        correct_guess = 0
        for i in range(total_codewords):
            if (decoded == A_error_free[i]).all(axis=1).any():
                correct_guess += 1
        print("failed decoding: {} / {}".format(total_codewords - ok.sum(),total_codewords)) # ok는 decoding 성공한 word개수를 뜻함. 즉 decoder가 생각하기에 자신이 decoding 실패한 codeword개수가 이 값임
        print("Correct codewords after decoding: ")
        print("Correct / Total = {} / {}".format(correct_guess,total_codewords) ) # 전체 중에 디코딩 성공한 거 개수
        print("Recovered {} more correct codewords".format(correct_guess - correct_codewords))


    # n, k = 7, 4
    # H = np.array([
    #     [1, 1, 0, 1, 1, 0, 0],
    #     [0, 1, 1, 0, 0, 1, 1],
    #     [1, 0, 1, 0, 1, 1, 0]
    # ], dtype=np.uint8)
    # A valid codeword for this H (toy)
    # c = np.array([1,0,0,0,1,0,0], dtype=np.uint8)
    #
    # # Add 1 and then 2 bit errors
    # r1 = c.copy(); r1[2] ^= 1
    # r2 = c.copy(); r2[[0,1]] ^= 1
    # print("r1 ",r1)
    # print("r2 ", r2)
    #
    #
    # decoded, ok, its, syn, flips = ldpc_bitflip_majority_decode(H, np.vstack([r1, r2]), max_iter=50, rng=0)
    # print("Decoded:\n", decoded)
    # print("Success:", ok, "Iters:", its, "Flips:", flips)
